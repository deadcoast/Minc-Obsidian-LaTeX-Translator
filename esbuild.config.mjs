import esbuild from 'esbuild';
import process from 'process';
import path from 'path';
import fs from 'fs';
import { tsconfigPathsPlugin } from 'esbuild-plugin-tsconfig-paths';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, visit the plugin's github repository
*/
`;

const prod = process.argv[2] === 'production';

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ['./main.ts'],
  bundle: true,
  external: ['obsidian'],
  format: 'cjs',
  loader: {
    '.ts': 'tsx',
    '.tsx': 'tsx',
  },
  target: 'es2020',
  logLevel: 'info',
  sourcemap: prod ? false : 'inline',
  treeShaking: true,
  outfile: 'main.js',
  plugins: [
    tsconfigPathsPlugin(),
    {
      name: 'alias-path',
      setup: (build) => {
        const tryResolve = (resolvedPath) => {
          // Try these extensions
          const extensions = ['.ts', '.tsx', '.js', '.jsx'];
          for (const ext of extensions) {
            const fullPath = resolvedPath + ext;
            if (fs.existsSync(fullPath)) {
              return fullPath;
            }
          }
          // If no extension matched, try as directory with index
          for (const ext of extensions) {
            const indexPath = path.join(resolvedPath, 'index' + ext);
            if (fs.existsSync(indexPath)) {
              return indexPath;
            }
          }
          return resolvedPath; // Let esbuild handle if not found
        };

        const resolve = (alias, filePath) => {
          const resolvedPath = path.join(process.cwd(), 'src', filePath.replace(`${alias}/`, ''));
          const finalPath = tryResolve(resolvedPath);
          return { path: finalPath, external: false };
        };

        // Handle @core/* imports
        build.onResolve({ filter: /^@core\// }, (args) => resolve('@core', args.path));
        // Handle @ui/* imports
        build.onResolve({ filter: /^@ui\// }, (args) => resolve('@ui', args.path));
        // Handle @components/* imports
        build.onResolve({ filter: /^@components\// }, (args) => resolve('@components', 'ui/components/' + args.path.replace('@components/', '')));
        // Handle @views/* imports
        build.onResolve({ filter: /^@views\// }, (args) => resolve('@views', 'ui/views/' + args.path.replace('@views/', '')));
        // Handle @hooks/* imports
        build.onResolve({ filter: /^@hooks\// }, (args) => resolve('@hooks', 'ui/hooks/' + args.path.replace('@hooks/', '')));
        // Handle @styles/* imports
        build.onResolve({ filter: /^@styles\// }, (args) => resolve('@styles', 'ui/styles/' + args.path.replace('@styles/', '')));
        // Handle @utils/* imports
        build.onResolve({ filter: /^@utils\// }, (args) => resolve('@utils', 'utils/' + args.path.replace('@utils/', '')));
      },
    },
  ],
  jsx: 'automatic',
  jsxImportSource: 'react',
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
